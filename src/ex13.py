oct1 = 252  # первый октет 
oct2 = 67   # второй октет
oct3 = 33   # третий октет
oct4 = 87   # четвертый октет

mask1 = 255 # значит первый октет не меняется т.к. полностью номер сети
mask2 = 252 # < 255 ===> часть октета будет меняться (конкретно последние 2 БИТА)
mask3 = 0   # весь октет будет меняться при подборе
mask4 = 0   # весь октет будет меняться при подборе

adres_seti1 = oct1 & mask1
adres_seti2 = oct2 & mask2
adres_seti3 = oct3 & mask3
adres_seti4 = oct4 & mask4

def octet_count_8(x):
    # количество единиц в двоичной записи октета
    return bin(x).count("1")

count = 0 # счетчик
# основной цикл. минимум для 2 октета - адрес сети
# максимум - если биты ВНЕ маски во втором октете (в этом случае 2 последних БИТА)
# будут равны 1
#                     минимум    максимум (сеть + макс биты вне маски)
for oktet2 in range(adres_seti2, adres_seti2 + (255 - mask2) + 1): # +1 потому что цикл не доходит до последнего 
    for oktet3 in range(256): # третий октет - судя по маске (0) подбираем все значения
        for oktet4 in range(256): # четвертый октет - судя по маске (0) подбираем все значения
            left = octet_count_8(adres_seti1) + octet_count_8(oktet2) # число бит в левых двух БАЙТАХ
            right = octet_count_8(oktet3) + octet_count_8(oktet4)     # число бит в правых двух БАЙТАХ
            if right > 2 * left:  # условие задачи
                count += 1
print(count)